// Generated by CoffeeScript 2.0.0-beta9-dev
var async, commentTransform, compilerAliases, concatAll, createIterator, fragmenter, resolveCompilerAlias;
fragmenter = function (mcOptions, options) {
  var anyFragExpr, createFragment, fragments, fragmentStack, srcPath, topFragment, topFragments;
  anyFragExpr = /#\s\((ember|em|coffee|cs|ecma|js|live|ls)\)\s*/;
  createFragment = function (lang, code) {
    return {
      type: lang,
      code: code
    };
  };
  fragmentStack = [mcOptions.lang || 'coffee'];
  fragments = [];
  topFragment = function (code) {
    return fragments.push(createFragment('coffee', code));
  };
  topFragments = function (fragments) {
    return topFragment(fragments.join('\n'));
  };
  topFragment('`import Ember from "ember"`');
  srcPath = options.input;
  if (srcPath.match(/app\/models\//))
    topFragments([
      '`import DS from "ember-data"`',
      'attr = DS.attr',
      'hasMany = DS.hasMany',
      'belongsTo = DS.belongsTo'
    ]);
  return {
    fragments: fragments,
    fragmentize: function (code) {
      var curFragment, index, matchTxt, nextFragMatch;
      nextFragMatch = code.match(anyFragExpr);
      if (!nextFragMatch)
        return this.fragments.push(createFragment(fragmentStack.shift(), code));
      matchTxt = nextFragMatch[0];
      index = code.indexOf(matchTxt);
      curFragment = code.slice(0, index);
      this.fragments.push(createFragment(fragmentStack.shift(), curFragment));
      fragmentStack.push(nextFragMatch[1]);
      return this.fragmentize(code.slice(index + matchTxt.length));
    }
  };
};
compilerAliases = {
  cs: 'coffee',
  em: 'ember',
  ecma: 'js',
  ls: 'live'
};
resolveCompilerAlias = function (alias) {
  return compilerAliases[alias] || alias;
};
commentTransform = function (compiled, type) {
  var compileComment;
  compileComment = '\n// compile fragment: ' + type + '\n';
  return compileComment.concat(compiled);
};
createIterator = function (compilers, mcOptions) {
  var transform;
  transform = mcOptions.transformer || commentTransform;
  return function (fragment, cb) {
    var code, compiled, type;
    type = resolveCompilerAlias(fragment.type);
    code = fragment.code;
    compiled = transform(compilers[type](code), type);
    return cb(null, compiled);
  };
};
async = require('async');
concatAll = function (code, compilers, cb, mcOptions, options) {
  var fragger;
  mcOptions = mcOptions || {};
  fragger = fragmenter(mcOptions, options);
  fragger.fragmentize(code);
  return async.concat(fragger.fragments, createIterator(compilers, mcOptions), function (err, results) {
    if (err)
      return next(err);
    return cb(results.join('\n'));
  });
};
module.exports = concatAll;
